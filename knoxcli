#!/bin/bash

# This is an auto-generated file. Tread with caution!

read -r -d '' filecontent <<EOR
clilogo()
{
	cat <<EOH
\\\`\\\`\\\`
██╗  ██╗███╗   ██╗ ██████╗ ██╗  ██╗ ██████╗██╗     ██╗
██║ ██╔╝████╗  ██║██╔═══██╗╚██╗██╔╝██╔════╝██║     ██║
█████╔╝ ██╔██╗ ██║██║   ██║ ╚███╔╝ ██║     ██║     ██║
██╔═██╗ ██║╚██╗██║██║   ██║ ██╔██╗ ██║     ██║     ██║
██║  ██╗██║ ╚████║╚██████╔╝██╔╝ ██╗╚██████╗███████╗██║
╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝  ╚═╝ ╚═════╝╚══════╝╚═╝
\\\`\\\`\\\`
EOH
}
EOR
. <(echo "$filecontent")
read -r -d '' filecontent <<EOR
#!/bin/bash

. \${ACCUKNOX_CFG:-~/.accuknox.cfg}

DIR=/tmp/\$\$
TMP=\$DIR/\$(basename \$0)

LOGLEVEL=\${LOGLEVEL:-1} #0=dbg, 1=info, 2=warn, 3=err
ak_dbg()
{
	[[ \$LOGLEVEL -gt 0 ]] && return
	echo "\$*"
}
ak_info()
{
	[[ \$LOGLEVEL -gt 1 ]] && return
	echo "\$*"
}
ak_warn()
{
	[[ \$LOGLEVEL -gt 2 ]] && return
	echo "\$*"
}
ak_err()
{
	[[ \$LOGLEVEL -gt 3 ]] && return
	echo "\$*"
}

ak_help()
{
	cat <<EOH
## Setting AccuKnox configuration
* Please note that AccuKnox configuration ('.accuknox.cfg') would be needed to run the cli. [ref](https://github.com/accuknox/tools/tree/main/api-samples#setting-accuknoxcfg)
* Use API_VERBOSE=2 <cmd> ... to dump the request response of all the AccuKnox API calls.
EOH
}

ak_api()
{
	apiverbosity=\${API_VERBOSE:-0}
	[[ \$apiverbosity -gt 0 ]] && echo "API: [\$1]"
	unset apicmd
	unset json_string
	read -r -d '' apicmd << EOH
curl \$CURLOPTS "\$1" \
	  -H "authorization: Bearer \$TOKEN" \
	  -H 'content-type: application/json' \
	  -H "x-tenant-id: \$TENANT_ID"
EOH
	if [ "\$data_raw" != "" ]; then
		apicmd="\$apicmd --data-raw '\$data_raw'"
	fi
	[[ \$apiverbosity -gt 1 ]] && echo "\$apicmd"
	json_string=\`eval "\$apicmd"\`
	if ! jq -e . >/dev/null 2>&1 <<<"\$json_string"; then
		echo "API call failed: [\$json_string]"
		exit 1
	fi
	[[ \$apiverbosity -gt 1 ]] && echo "\$json_string"
	unset data_raw
}

ak_prereq()
{
	[[ "\$DIR" != "" ]] && mkdir -p \$DIR
	command -v jq >/dev/null 2>&1 || { echo >&2 "require 'jq' to be installed. Aborting."; exit 1; }
	ak_dbg "tenant-id: \$TENANT_ID"
}

function ak_cleanup {
	[[ "\$DIR" != "" ]] && rm -rf \$DIR
}

trap ak_cleanup EXIT

ak_prereq
EOR
. <(echo "$filecontent")
# ----------- [cluster] command handler -----------------------
read -r -d '' filecontent <<EOR
cluster_help()
{
	cat <<EOH
## [cluster] command

[cluster] command operates on Kubernetes and Virtual Machines based clusters.

EOH
}

cluster_cmd()
{
	echo "check further [cluster] options ..."
}
EOR
. <(echo "$filecontent")
# ----------- end of [cluster] command handler ----------------
# ----------- [cluster_alerts] command handler -----------------------
read -r -d '' filecontent <<EOR
clusterjq='.[] | select(.ClusterName|test("idt")'
alertjq='.'
stimestr="2 days ago"
stime=\$(date -d "\$stimestr" +%s)
etime=\$(date +%s)
alerttype="kubearmor"
filters=""

cluster_alerts_help()
{
	cat <<EOH
### [cluster alerts] command

Options supported:
* --clusterjq [jq-spec]: jq filter to be used on cluster list output (default: '\$clusterjq')
* --alertjq [jq-spec]: jq filter to be used on cluster list output (default: '\$alertjq')
* --stime [datetime]: start time in epoch format (default: \$stimestr)
* --etime [datetime]: end time in epoch format (default: now)
* --type [alert-type]: alert-type (default: "\$alerttype")
* --filters [filter-spec]: Alert filters to be passed to API (default: '\$filters')

Examples:
1. knoxcli cluster alerts --alertjq '.response[] | select(.Resource // "unknown" | test("ziggy"))' <br>
	... list all the alerts containing 'ziggy' in the Resource filter
2. knoxcli cluster alerts --filters '{"field":"HostName","value":"store54055","op":"match"}' --alertjq '.response[] | "hostname=\(.HostName),resource=\(.Resource//""),UID=\(.UID),operation=\(.Operation)"' <br>
	... get all alerts for HostName="store54055" and print the response in following csv format hostname,resource,UID,operation

> Difference between --alertjq and --filters? <br>
> --filters are passed directly to the AccuKnox API. --alertjq operates on the output of the AccuKnox API response. It is recommended to use --filters as far as possible. However, you can use regex/jq based matching criteria with --alertjq.

EOH
}

cluster_alerts_query()
{
	for((pgid=1;;pgid++)); do
		data_raw="{\"Namespace\":[],\"FromTime\":\$stime,\"ToTime\":\$etime,\"PageId\":\$pgid,\"PageSize\":50,\"Filters\":[\$filters],\"ClusterID\":[\$cidlist],\"View\":\"List\",\"Type\":\"\$alerttype\",\"WorkloadType\":[],\"WorkloadName\":[],\"WorkspaceID\":\$TENANT_ID}"
		ak_api "\$CWPP_URL/monitors/v1/alerts/events?orderby=desc"
		acnt=\$(echo \$json_string | jq '.response | length')
		[[ \$acnt -le 0 ]] && break
		echo \$json_string | jq "\$alertjq"
	done
}

cluster_alerts_args()
{
    OPTS=\`getopt -o f:hs:e: --long "stime: etime: clusterjq: type: filters: alertjq: help" -n 'parse-options' -- "\$@"\`
    eval set -- "\$OPTS"
    while true; do
        case "\$1" in
            --type)         alerttype="\$2";                shift 2;;
            --clusterjq)    clusterjq="\$2";                shift 2;;
            --alertjq)      alertjq="\$2";                  shift 2;;
            --filters | -f) filters="\$2";                  shift 2;;
			--stime | -s)   stime=\$(date --date "\$2" +%s); shift 2;;
			--etime | -e)   etime=\$(date --date "\$2" +%s); shift 2;;
            -h | --help )   cluster_alerts_help;            exit 2;;
            -- ) shift; break ;;
            * ) break ;;
        esac
    done
	[[ \$etime -lt \$stime ]] && echo "etime should be greater than stime" && exit 2
}

cluster_alerts_cmd()
{
	cluster_alerts_args "\$@"
	ak_api "\$CWPP_URL/cluster-onboarding/api/v1/get-onboarded-clusters?wsid=\$TENANT_ID"
	final_json=\$(echo \$json_string | jq -r "\$clusterjq")
	cidlist=""
	while read cline; do
		cid=\${cline/ */}
		cname=\${cline/* /}
		[[ "\$cidlist" != "" ]] && cidlist="\$cidlist,"
		cidlist="\$cidlist\"\$cid\""
	done < <(echo \$final_json | jq -r '. | "\(.ID) \(.ClusterName)"')
	cluster_alerts_query
}
EOR
. <(echo "$filecontent")
# ----------- end of [cluster_alerts] command handler ----------------
# ----------- [cluster_list] command handler -----------------------
read -r -d '' filecontent <<EOR
clusterjq='.[] | "id=\(.ID),name=\(.ClusterName),status=\(.Status)"'
nodejq='.result[].NodeName'
spec=".*"
show_nodes=0

cluster_list_help()
{
	cat <<EOH
### [cluster list] command
* --spec | -s: [requires value] search filter for cluster names (regex based)
* --nodes | -n: lists nodes from the clusters
* --clusterjq: jq filter to be used on cluster list output (default: '\$clusterjq')
* --nodejq: jq filter to be used on node list output (default: '\$nodejq')

Examples:

1. knoxcli cluster list --clusterjq '.[] | select(.ClusterName|test("idt."))' --nodes <br>
	... list all the clusters with idt substring in its names and list all the nodes in those clusters
2. knoxcli cluster list --clusterjq '.[] | select((.type == "vm") and (.Status == "Inactive")) | "id=\(.ID),name=\(.ClusterName),status=\(.Status)"' <br>
	... list all the Inactive VM clusters and print their ID,name,status

EOH
}

cluster_list_get_node_list()
{
	echo "List of nodes in cluster [\$cname]:"
	data_raw="{\"workspace_id\":\$TENANT_ID,\"cluster_id\":[\$cid],\"from_time\":[],\"to_time\":[]}"
	ak_api "\$CWPP_URL/cm/api/v1/cluster-management/nodes-in-cluster"
	echo \$json_string | jq -r "\$nodejq"
}

cluster_list_cmd()
{
    # Remember to specify : in cases where argument is nessary both in short and long options
    OPTS=\`getopt -o hns: --long "nodes spec: clusterjq: nodejq: help" -n 'parse-options' -- "\$@"\`
    eval set -- "\$OPTS"
    while true; do
        case "\$1" in
            -s | --spec )  spec="\$2";                 shift 2;;
            -n | --nodes ) show_nodes=1;              shift 1;;
            --nodejq )     nodejq="\$2"; show_nodes=1; shift 2;;
            --clusterjq)   clusterjq="\$2";            shift 2;;
            -h | --help )  cluster_list_help; return; shift 1;;
            -- ) shift; break ;;
            * ) break ;;
        esac
    done
	echo "List of clusters:"
	ak_api "\$CWPP_URL/cluster-onboarding/api/v1/get-onboarded-clusters?wsid=\$TENANT_ID"
	echo \$json_string | jq -r "\$clusterjq"
	[[ \$show_nodes -eq 0 ]] && return
	while read cline; do
		cid=\${cline/ */}
		cname=\${cline/* /}
		[[ ! \$cname =~ \$spec ]] && ak_dbg "ignoring cluster [\$cname] ..." && continue
		cluster_list_get_node_list
	done < <(echo \$json_string | jq -r '.[] | "\(.ID) \(.ClusterName)"')
}
EOR
. <(echo "$filecontent")
# ----------- end of [cluster_list] command handler ----------------
# ----------- [cluster_policy] command handler -----------------------
read -r -d '' filecontent <<EOR
clusterjq='.[]'
policyjq='.'
polout="policydump"
operation="list"

cluster_policy_help()
{
	cat <<EOH
### [cluster policy] command
* --operation [list | dump]: Dump the policies in --dumpdir folder or list the policies
* --dumpdir | -d: Policy dump directory
* --clusterjq: jq filter to be used on cluster list output (default: '\$clusterjq')
* --policyjq: jq filter to be used on policy list output (default: '\$policyjq')

Examples:

1. knoxcli cluster policy --clusterjq '.[] | select(.ClusterName|test("gke"))' --policyjq '.list_of_policies[] | select(.name|test("crypto"))' <br>
	... get all the policies have 'crypto' in their name for all the clusters having 'gke' in their name

2. knoxcli cluster policy --clusterjq '.[] | select(.ClusterName|test("gke"))' --policyjq '.list_of_policies[] | select(.namespace_name // "notpresent"|test("agents"))' <br>
	... get all the policies in namespace agents ... if no namespace is present then "notpresent" is substituted.
EOH
}

cluster_policy_dump_policy_file()
{
	ak_api "\$CWPP_URL/policymanagement/v2/policy/\$1"
	echo "\$json_string" | jq -r .yaml > \$polpath
	[[ \$? -ne 0 ]] && echo "could not get policy with ID=[\$1]" && return
}

cluster_policy_get_policy_list()
{
	polperpage=10
	for((pgprev=0;;pgprev+=\$polperpage)); do
		pgnext=\$((\$pgprev + \$polperpage))
		echo "fetching policies \$pgprev to \$pgnext ..."
		data_raw="{\"workspace_id\":\$TENANT_ID,\"workload\":\"k8s\",\"page_previous\":\$pgprev,\"page_next\":\$pgnext,\"filter\":{\"cluster_id\":[\$1],\"namespace_id\":[],\"workload_id\":[],\"kind\":[],\"node_id\":[],\"pod_id\":[],\"type\":[],\"status\":[],\"tags\":[],\"name\":{\"regex\":[]},\"tldr\":{\"regex\":[]}}}"
		ak_api "\$CWPP_URL/policymanagement/v2/list-policy"
		pcnt=\$(echo "\$json_string" | jq '.list_of_policies | length')
		[[ \$pcnt -eq 0 ]] && echo "finished" && break
		final_json=\$(echo "\$json_string" | jq -r "\$policyjq")
		[[ "\$final_json" == "" ]] && continue
		while read pline; do
			arr=(\$pline)
			if [ "\$operation" == "dump" ]; then
				poldir=\$cpath/\${arr[2]}
				mkdir -p \$poldir 2>/dev/null
				polpath=\$poldir/\${arr[1]}.yaml
				echo \$polpath
			else
				polpath=/dev/stdout
			fi
			cluster_policy_dump_policy_file \${arr[0]}
		done < <(echo \$final_json | jq -r '. | "\(.policy_id) \(.name) \(.namespace_name)"')
	done
}

cluster_policy_cmd()
{
    # Remember to specify : in cases where argument is nessary both in short and long options
    OPTS=\`getopt -o d:h --long "operation: policyjq: dumpdir: clusterjq: help" -n 'parse-options' -- "\$@"\`
    eval set -- "\$OPTS"
    while true; do
        case "\$1" in
            --operation)    operation="\$2";                shift 2;;
            --clusterjq)    clusterjq="\$2";                shift 2;;
            --policyjq)     policyjq="\$2";                 shift 2;;
            -d | --dumpdir) polout="\$2"; operation="dump"; shift 2;;
            -h | --help )  cluster_policy_help; return;    shift 1;;
            -- ) shift; break ;;
            * ) break ;;
        esac
    done
	[[ "\$operation" != "list" ]] && [[ "\$operation" != "dump" ]] && echo "invalid operation [\$operation]!" && return
	ak_api "\$CWPP_URL/cluster-onboarding/api/v1/get-onboarded-clusters?wsid=\$TENANT_ID"
	filter_json=\$(echo \$json_string | jq -r "\$clusterjq")
	while read cline; do
		cid=\${cline/ */}
		cname=\${cline/* /}
		if [ "\$operation" == "dump" ]; then
			cpath=\$polout/\$cname
			mkdir \$cpath 2>/dev/null
		fi
		echo "fetching policies for cluster [\$cname] ..."
		cluster_policy_get_policy_list \$cid
	done < <(echo "\$filter_json" | jq -r '. | "\(.ID) \(.ClusterName)"')
}
EOR
. <(echo "$filecontent")
# ----------- end of [cluster_policy] command handler ----------------
# ----------- [image] command handler -----------------------
read -r -d '' filecontent <<EOR
image_help()
{
	cat << EOH
## [image] command
[image] commands operates on container images and corresponding findings.

EOH
}

image_cmd()
{
    # Remember to specify : in cases where argument is nessary both in short and long options
    OPTS=\`getopt -o hp:l: --long "period: label: help" -n 'parse-options' -- "\$@"\`
    eval set -- "\$OPTS"
    while true; do
        case "\$1" in
            -p | --period ) timeperiod="\$2"; shift 2;;
            -l | --label ) label="\$2"; shift 2;;
            -h | --help ) image_help; return; shift 1;;
            -- ) shift; break ;;
            * ) break ;;
        esac
    done
    echo "timeperiod: \$timeperiod"
    echo "label: \$label"
	echo "Executing image..."
}
EOR
. <(echo "$filecontent")
# ----------- end of [image] command handler ----------------
# ----------- [image_list] command handler -----------------------
read -r -d '' filecontent <<EOR
image_list_help()
{
	echo "image list [options]"
	echo "      --filter | -f: image list filters"
	echo "      --label  | -l: image assets with label"
}

image_list_cmd()
{
    # Remember to specify : in cases where argument is nessary both in short and long options
    OPTS=\`getopt -o hf:l: --long "filter: label: help" -n 'parse-options' -- "\$@"\`
    eval set -- "\$OPTS"
    while true; do
        case "\$1" in
            -f | --filter ) filter="\$2"; shift 2;;
            -l | --label ) label="\$2"; shift 2;;
            -h | --help ) image_list_help; return; shift 1;;
            -- ) shift; break ;;
            * ) break ;;
        esac
    done
    echo "filter: \$filter"
    echo "label: \$label"
	echo "Executing image list..."
}
EOR
. <(echo "$filecontent")
# ----------- end of [image_list] command handler ----------------
# ----------- [image_scan] command handler -----------------------
read -r -d '' filecontent <<EOR
image_scan_help()
{
	echo "image scan [options]"
	echo "      --spec | -s: Images to be scanned (regex can be specified)"
}

image_scan_cmd()
{
    # Remember to specify : in cases where argument is nessary both in short and long options
    OPTS=\`getopt -o hs: --long "spec: help" -n 'parse-options' -- "\$@"\`
    eval set -- "\$OPTS"
    while true; do
        case "\$1" in
            -s | --spec ) spec="\$2"; shift 2;;
            -h | --help ) image_scan_help; return; shift 1;;
            -- ) shift; break ;;
            * ) break ;;
        esac
    done
    echo "spec: \$spec"
	echo "Executing image scan..."
}
EOR
. <(echo "$filecontent")
# ----------- end of [image_scan] command handler ----------------

# Processing starts here ...
unset cmd
while true; do
	[[ ${1:--} == -* ]] && break #if arg is empty or starts with '-'
	[[ "$cmd" != "" ]] && cmd="${cmd}_"
	cmd="$cmd$1"
	shift
done
case "$cmd" in
	"cluster")
		cluster_cmd "$@"
		;;
	"cluster_alerts")
		cluster_alerts_cmd "$@"
		;;
	"cluster_list")
		cluster_list_cmd "$@"
		;;
	"cluster_policy")
		cluster_policy_cmd "$@"
		;;
	"image")
		image_cmd "$@"
		;;
	"image_list")
		image_list_cmd "$@"
		;;
	"image_scan")
		image_scan_cmd "$@"
		;;
	"version")
		echo "version: v0.2"
		;;
	* | help)
		[[ "$(type -t clilogo)" == "function" ]] && clilogo
		echo "# $0 command options"
		echo "\`\`\`"
		echo "$0"
		echo -en "\tcluster\n"
		echo -en "\tcluster alerts\n"
		echo -en "\tcluster list\n"
		echo -en "\tcluster policy\n"
		echo -en "\timage\n"
		echo -en "\timage list\n"
		echo -en "\timage scan\n"
		echo -en "\tversion\n"
		echo -en "\thelp\n"
		echo "\`\`\`"

		cluster_help
		cluster_alerts_help
		cluster_list_help
		cluster_policy_help
		image_help
		image_list_help
		image_scan_help
		;;
esac